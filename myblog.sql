/*
Navicat MySQL Data Transfer

Source Server         : blog
Source Server Version : 50562
Source Host           : 39.107.24.183:3306
Source Database       : myblog

Target Server Type    : MYSQL
Target Server Version : 50562
File Encoding         : 65001

Date: 2019-12-17 19:42:03
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for Blog
-- ----------------------------
DROP TABLE IF EXISTS `Blog`;
CREATE TABLE `Blog` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `content` longtext,
  `create_date` date DEFAULT NULL,
  `summary` varchar(255) DEFAULT NULL,
  `tittle` varchar(255) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_833kovmh3tq17pjgbq8k73wsx` (`category_id`),
  CONSTRAINT `FK_833kovmh3tq17pjgbq8k73wsx` FOREIGN KEY (`category_id`) REFERENCES `Category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of Blog
-- ----------------------------
INSERT INTO `Blog` VALUES ('1', '##Java历史概述\nJava是于1995.5由Sun公司推出，由高斯林Gosling等人开发，2009Sun公司被Oracle公司收购\n##Java特点\n1.面向对象\n两大要素:类，对象\n特性:封装，继承，多态\n2.健壮性\n封装C/C++的指针问题\n垃圾回收机制防止内存溢出\n3.跨平台性\nwrite once,run anywhere 编写一次，到处运行 归功于Java虚拟机功劳\n4.多线程\n##JDK组成\n1.JDK是Java开发工具包其中包括Java开发工具和JRE\n2.Java开发工具包括javac.exe编译工具，java.exe运行工具，jar.exe项目打包工具,javadoc文档生成工具等\n3.JRE是Java运行环境包括Java虚拟机(JVM)和核心类库\n##Java核心机制\n1.类加载机制(分配内存由Java虚拟机来完成)\n2.垃圾回收机制(回收内存防止内存溢出但不代表内存就不会溢出)\n##Java运行过程\n1.编写Java源文件(.java文件)\n2.编译Java源文件(由javac.exe工具完成生成字节码文件.class文件)\n3.运行Java字节码文件(由java.exe工具完成由JVM类加载机制分配内存空间)\n##Java常用开发工具命令\n1.javac.exe编译工具\n~~~\njavac 源文件名.java \n例如编译Hello.java文件 javac Hello.java\n~~~\n2.java.exe运行工具\n~~~\njava 字节码文件名 \n例如运行Hello.class字节码文件 java Hello\n~~~\n3.jar.exe打包工具\n~~~\njar cvf 指定目录生成jar包 需要打包的字节码文件 \n例如打包Hello.class文件到当前目录的Hello.jar中 jar cvf Hello.jar Hello.class\n~~~\n4.javadoc帮助文档生成工具\n~~~\njavadoc -d 指定生成目录文件名 -author -version java源文件(.java) \n例如生成Hello.java帮助文档到当前目录下Hello文件夹 javadoc -d Hello -author -version Hello.java\n~~~\n##补充IDE生成帮助文档方法\n1.eclipse\n~~~\nProject--->Generate Javadoc\n~~~\n![](/images/eclipse.png)\n2.idea\n~~~\nTools--->Generate Javadoc\n~~~\n![](/images/idea.png)\n###注意乱码问题\n~~~\n-encoding utf-8 -charset utf-8\n~~~\n##注释\n1.单行注释\n~~~\n//这是单行注释\n~~~\n2.多行注释\n~~~\n/*\n这是多行注释\n*/\n~~~\n3文档注释\n~~~\n/**\n@author 君莫笑\n@version v1\n这是文档注释\n*/\n~~~\n###注意事项\n单行注释和多行注释的内容不会被编译到字节码文件中，但是javadoc工具可以解析文档注释\n\n\n', '2019-08-22', '概述Java语言特性，JDK的组成部分及其应用，内部机制及其运行原理', 'Java入门概述', '0');
INSERT INTO `Blog` VALUES ('2', '##下载JDK\n1.JDK版本号说明\n**JDK 1.X===JDK X.0**\n2.下载JDK1.8(8.0)\n~~~\njdk1.8.0_181\n~~~\n~~~\n--bin //Java开发工具有重要的javac.exe,java.exe,jar.exe,javadoc.exe\n--include //本地库\n--jre //Java运行环境\n--lib //核心类库\n--src.zip //JavaSE源码\n~~~\n3.下载JRE防止IDE识别不了Java运行环境\n~~~\njre1.8.0_181\n~~~\n4.配置JDK\n~~~\n目的:为了使jdk1.8.0_181/bin目录下的开发工具运行在各个目录\n操作:\n电脑--点击右键->属性--->高级系统设置--->环境变量\n∵系统变量级别>用户变量级别∴将Java配置到系统变量级别\n配置JAVA_HOME系统变量\n例如C:\\Program Files\\Java\\jdk1.8.0_181\n配置JAVA_HOME原因：\n//1.方便修改JDK版本灵活性增强\n//2.方便第三方中间件如Tomcat自动识别JDK版本否则无法识别JDK版本导致不能运行Web项目\n配置PATH\n%JAVA_HOME%\\bin 并上移到第一位\n~~~\n##具体配置效果如下\n![](/images/JAVA_HOME.png)\n![](/images/PATH.png)\n5.验证是否配置成功\n~~~\n命令行中输入javac,java命令行若出现帮助内容则配置成功\n~~~\n##第一行程序代码Hello,World\n~~~\n1.在指定目录下创建java源文件.java文件\n注意问题\n2.文件扩展名问题:电脑-->查看-->文件扩展名\n3.编写java源文件\n/**\n@author 君莫笑\n@version v0\n第一个HelloWorld程序\n*/\n/*\n编写第一行Java程序\n*/\n/*一个源文件只能只有一个public class,一个public class对应一个源文件,但是一个源文件中可以有多个class和各自的方法\n*/\npublic class HelloWorld {\n  //主方法程序的入口\n  public static void main(String args[]) {\n    System.out.println(\"Hello,World...\");\n  }\n}\n4.控制台命令行中cd到指定目录下\n5.编译源文件 javac 源文件名.java 如下 javac HelloWorld.java \n结果生成 HelloWorld.class字节码文件\n6.运行字节码文件 java HelloWorld\n7.JVM类加载机制分配内存空间，垃圾回收机制回收内存\n~~~\n##注意事项 复制到文本编辑器的乱码问题\n~~~\n原因:字符集读写不能统一，数据存储是UTF-8,数据读取GBK\n解决方法:将源文件的编码改为ANSI（GBK）即可\n~~~\n\n\n', '2019-08-22', 'Java环境搭建的相关说明及配置，第一个Java程序Hello,World', 'Java环境搭建', '2');
INSERT INTO `Blog` VALUES ('8', '##Java关键字\n~~~\n定义:用于描述Java语言的特殊字符串\n特点:都是小写开始 例如 class,public,void,interface,private等等\n~~~\n##Java保留字\n~~~\n定义:Java中存在的但并未定义为关键字范畴的特殊字符串并且以后有可能被定义为关键字 例如goto,const\n~~~\n##Java标识符\n~~~\n定义:Java程序员对类，包，方法等进行描述说明的字符串\n~~~\n##Java标识符的命名规则\n~~~\nJava标识符由26个大小写字母，0-9个数字，_和$符号组成，但是不能以数字开头 例如 Hello_$,$_World等命名\nJava标识符不能是关键字或者保留字但是可以包含关键字和保留字 如 HelloPublic,HelloClass等\nJava标识符严格区分大小写，没有长度限制\nJava标识符不能出现空格\n~~~\n**注意事项:如果Java标识符不能按照规则来命名会出现编译错误**\n##Java标识符的命名规范\n~~~\n包名:aabbcc 例如:com.thxy.entity\n类名:AaBbCc 例如 public class HelloWorld\n变量名:aaBbCc 例如 String myName\n方法名:aaBbCc 例如 public void getName()\n常量名:AA_BB_CC 例如 public static final String sunName=\"SUN_INSTANCE\"\n~~~\n**注意事项:如果Java标识符不能按照规范命名不会出现编译错误，但是会降低代码可读性，也会降低代码的可维护性。建议在命名Java标识符时可以“见名知意”,例如getStudentName（）很明显这个方法就是获取Student类的name属性方法**\n##Java数据类型分类\n~~~\n基本数据类型:boolean,byte,char,short,int,long,float,double\n引用类型:class（包括String类 任何一个字符串都是String类的一个实例实现）,interface,array[]数组\n~~~\n##字节与位换算关系\n~~~\n字节 byte\n位 bit\n1字节=8位(1 byte = 8bit)\n~~~\n##整数类型详解\n~~~\n所占内存空间大小:byte(1字节)，short(2字节)，int(4字节)，long（8字节）\n容量大小 byte < short < int < long\n取值范围\nbyte（位）:最小值 -2^（8-1） - 最大值 2^（8-1）-1 \nshort : 最小值 -2^(16-1) - 最大值 2^(16-1)-1\nint :   最小值-2^(32-1) - 最大值 2^(32-1)-1\nlong : 最小值 -2^（64-1）-  最大值 2^（64-1）-1\n求整数类型取值范围方法:-2^(字节数*8-1)-2^(字节数*8-1)-1\n~~~\n~~~\n##为什么位数-1\n因为忽略符号位所以-1\n~~~\n~~~\n##为什么正数取值范围-1\n因为中间有个0所以正数范围要-1\n~~~\n##科学计算法\n~~~\nE+数字”表示E之前的数字要乘以10的多少倍。\n比如3.14E3就是3.14×1000=3140\n比如3.14E-3就是3.14/1000=0.00314\n~~~\n##浮点类型\n~~~\n所占内存空间大小:float（4字节），double(8字节)\n容量大小:float < double\n取值范围\nfloat最大值:Float.MAX_VALUE 3.4028235E38\nfloat最小值:Float.MIN_VALUE 1.4E-45\ndouble最大值:Double.MAX_VALUE 1.7976931348623157E308\ndouble最小值:Double.MIN_VALUE 4.9E-324\n~~~\n**注意float,double和int,long类型所占空间大小相同但是float,double类型容量大小却比int,long大得多**\n##布尔类型（逻辑类型）\n~~~\n所占内存空间大小:1字节\n取值范围:true,false\n~~~\n##字符类型\n~~~\n所占内存空间：2字节\n取值范围:任意一个字符\n~~~\n##基本数据类型的声明和赋值\n~~~\n数据类型声明:数据类型 变量名;\n数据赋值: 变量名=面量值;\n~~~\n~~~\n注意:\nlong类型声明赋值:结尾显式使用\'L\'或者\'l\'标明是long类型 如 long l=12341231123123L。若不加则默认为int,如 long l=123表示long存储int类型。若超过int范围就要加L或者l来识别long类型否则编译会报错\nfloat类型声明赋值:结尾显式使用\'F\'或者\'f\'标明是float类型，如 float f=12.3F。若不加则默认为double，如 float f=12.3表示float类型存储double。显然是不行的，原因超过float存储范围JVM会编译报错\n~~~\n##字符数据类型赋值\n~~~\n字符类型赋值有三种情况:\'\'一般一个字符赋值，\'\\\'转义赋值,unicode赋值\n~~~\n~~~\n例如:\nchar c; c=\'a\';\nchar c1; c1=\'\\n\';\nchar c2; c2=97; \n~~~\n##基本数据类型之间运算规则（不包括布尔类型）\n~~~\n自动提升类型\n强制转换\n~~~\n##自动提升类型\n**默认情况下:整数常量的类型是int,浮点数常量类型是double**\n**容量小的向容量大的类型转byte,char,short ---->int----->long ----->float---->double**\n**byte,char,short之间或自身进行运算时都是自动提升为int**\n~~~\n例如\n正确代码\nbyte b= 127;\nint i=b+1;\n错误代码\nbyte b= 127;\nbyte b1=b+1;//b+1类型是int不能定义byte数据类型来接收\n~~~\n~~~\n经典题\nSystem.out.println(\'*\'+\'*\');\n/*\n结果84\n显然char与char之间运算返回的数据类型是int\n*/\n~~~\n##强制转换类型\n~~~\n使用原因：用容量较大的数据类型去保存较小数据量时可以使用强制转换类型定义容量较小的数据类型来保存。\n~~~\n~~~\n例如:数据库中查询数据量时返回的是默认long类型，但是我们的数据量却不是这么大，就可以定义int类型来接收 int count=(int)select count(*) from User;查询数据库数据量默认为long类型\n~~~\n~~~\n再例如:当我们使用char类型和整数常量做运算时由于自动提升类型的关系我们并不能得到我们理想的char类型的字符，这时可以使用强制转换为char字符类型 char c=(char)(\'a\'+1)\n~~~\n##变量的作用域\n~~~\n分类:\n成员变量:类中定义的变量:类变量(static修饰)，实例变量\n局部变量:方法或构造器中定义的参数，方法中定义的变量(需要显式初始化)，代码块中定义的变量(需要显式初始化)\n~~~\n~~~\n规则:\n变量先声明再使用\n变量只能在作用域的范围内才可以被调用\n同一个作用域中的不能重复定义变量\n成员变量可以在该类中的任何地方调用\n局部变量只能在定义变量的方法中调用\n~~~\n~~~\n例子\n//定义一个类\npublic class Person {\n //成员变量中的类变量(static修饰)\n private static String personName=\"君莫笑\";//默认为null;\n //主方法\n public static void main(String[] args){\n    	System.out.println(\"类中定义的类变量:\"+personName);\n		getPersonName(\"君莫笑\");\n		//报错 name cannot be resolved to a variable\n    	System.out.println(name);\n		//报错 age cannot be resolved to a variable\n		System.out.println(age);\n }\n public static void getPersonName(String name){\n      //方法中定义的局部变量\n      int age=18;\n	  System.out.println(\"类中定义的类变量:\"+personName);\n	  System.out.println(\"方法中定义的局部变量:\"+age+\",\"+\"方法参数中定义的局部量:\"+name);\n }\n} \n//显然:方法中定义的局部变量age,name不在作用域范围内就会失效,而类中定义的类变量personName可以在该类中任何地方调用\n~~~\n##引用数据类型String\n~~~\n定义:String是一个类，任何一个字符串都是String类的实现\n声明及赋值：String s; s=\"abc\";\n##注意:字符串String与字符char区别，String是存储多个字符用\"\"赋值，char是存储一个字符用\'\'赋值,String可以定义为String s=\"\";而char不行char c=\'\';会编译报错\n~~~\n##String与基本数据类型的运算情况\n~~~\n运算规则:连接运算\n运算结果类型为String引用类型，所以我们可以这么说任何基本数据类型和String类型运算返回的都是String类型（从做到右运算有括号先算括号）\n~~~\n~~~\n例如String与整数类型运算\n正确代码\nint i=100;\nString s=\"Hello\";\nSystem.out.println(s+i);\n/*\n结果Hello100\n显然返回结果是String类型\n*/\n~~~\n~~~\n例如String类型与字符类型运算\nchar a=\'a\';//一般字符类型表示\nchar b=\'\\n\';//转义字符表示\nchar c=97;//unicode表示\nString s=\"Hello\";\nSystem.out.println(s+a);\nSystem.out.println(s+b);\nSystem.out.println(s+c);\n/*\n结果\nHelloa\nHello\n\nHelloa\n显然返回结果是String类型\n*/\n~~~\n~~~\n例如String与浮点数据类型运算\nfloat f=12.34F;\ndouble d=1234.22;//默认double类型\nString s=\"Hello\";\nSystem.out.println(s+f);//连接运算\nSystem.out.println(s+d);\n/*\n结果\nHello12.34\nHello1234.22\n显然返回结果是String类型\n*/\n~~~\n##String引用类型转换为基本数据类型（不含字符类型和布尔类型）\n~~~\npublic class HelloWorld {\n	public static void main(String[] args) {\n		String string = \"123\";\n		byte b = Byte.parseByte(string);\n		short s = Short.parseShort(string);\n		int i = Integer.parseInt(string);\n		long l = Long.parseLong(string);\n		float f = Float.parseFloat(string);\n		double d = Double.parseDouble(string);\n		System.out.println(b);\n		System.out.println(s);\n		System.out.println(i);\n		System.out.println(l);\n		System.out.println(f);\n		System.out.println(d);\n	}\n}\n/*\n结果\n123\n123\n123\n123\n123.0\n123.0\nString转换基本数据类型时使用parseXXX(String)即可\n*/\n~~~\n\n', '2019-08-26', 'Java基本数据类型之间的运算规则(不含逻辑类型)与注意项，Java引用类型的应用，字符串的运算规则和注意项', '详解Java数据类型', '0');
INSERT INTO `Blog` VALUES ('9', '##常用进制概述\n~~~\n二进制:逢2进1 例子:0b11,0b10,0b110等\n八进制:逢8进1 例子：023,076,045等\n十进制:逢10进1 例子:90,997,89等\n十六进制:逢16进1 例子:0xAE,0x123,0x876B等\n~~~\n~~~\n计算机底层以二进制存储数据\n计算机的数据以补码的方式进行存储\n~~~\n##二进制转换为十进制 1字节=8位 最高位是符号位\n~~~\n正数二进制转十进制三码合一即补码=反码=原码\n二进制:\n0 0 0 0 1 1 1 1 补码\n十进制:\n1*2^3+1*2^2+1*2^1+1*2^0=15\n~~~\n~~~\n负数二进制转十进制原则:补码-->反码--->原码\n二进制:\n1 0 1 0 1 0 1 0 补码 计算机存储方式\n-1\n1 0 1 0 1 0 0 1 反码\n取反\n1(符号位) 1 0 1 0 1 1 0 原码\n十进制:\n-(1*2^6+1*2^4+1*2^2+1*2^1)=-86\n~~~\n##十进制转换为二进制\n~~~\n原则:除2取余逆直到商是0\n十进制:100\n二进制:0 1 1 0 0 1 0 0\n~~~\n##二进制转换八进制 8=2^3\n~~~\n原则:二进制末尾开始的每三位数为八进制末尾一个数，不够位0来筹\n二进制:0 1 1 0 1 0 1 0\n八进制:0152\n~~~\n##八进制转换二进制\n~~~\n原则:八进制末尾每一位数为二进制末尾三位数，不够位0来筹\n八进制：0267\n二进制：1 0 1 1 0 1 1 1\n~~~\n##二进制转换十六进制 16=2^4\n~~~\n原则:二进制末尾开始的每四位数是十六进制末尾一位数，不够位0来筹\n二进制:0 1 0 1 0 1 0 0\n十六机制:0x54\n~~~\n##十六进制转换二进制\n~~~\n原则:十六进制末尾开始的每一位数是二进制末尾四位数，不够位0来筹\n十六进制:0x86\n二进制:1 0 0 0 0 1 1 0\n~~~\n##解决强制转换问题\n~~~\n问题:\nbyte b=127;\nbyte b1=(byte)(b+1);\nSystem.out.println(b1);\n/*\n结果:\n-128\n*/\n~~~\n~~~\n问题分析:经典\n十进制:127\n二进制:\n0 1 1 1 1 1 1 1 127原码=反码=补码\n+1\n1（符号位） 0 0 0 0 0 0 0 -128补码\n1 1 1 1 1 1 1 1 -127原码\n符号位不变，其余取反\n1 0 0 0 0 0 0 0 -127反码\n+1\n1 0 0 0 0 0 0 1 -127补码\n-1\n1（符号位） 0 0 0 0 0 0 0 -128补码 计算机存储方式\n~~~\n##API提供的进制转换方法\n~~~\ntoBinaryString(int i) 在基数2中返回整数参数的字符串表示形式为无符号整数。 \ntoHexString(int i) 返回整数参数的字符串表示形式，作为16位中的无符号整数。 \ntoOctalString(int i) 在基数8中返回整数参数的字符串表示形式为无符号整数。 \n~~~\n~~~\n      int i=98;\n	  String binaryString=Integer.toBinaryString(i);\n	  String octalString=Integer.toOctalString(i);\n	  String hexString=Integer.toHexString(i);\n	  System.out.println(\"二进制\"+binaryString+\",八进制\"+octalString+\",十六进制\"+hexString);\n	  /*\n	  结果:二进制1100010,八进制142,十六进制62\n	  */\n~~~\n', '2019-08-26', '二进制，十进制，八进制，十六进制之间换算；原码，反码，补码之间的转换', '进制之间的运算', '0');
INSERT INTO `Blog` VALUES ('10', '##Java运算符分类\n~~~\n算数运算符:+,—,*,/,(前)++,(后)++,%,+(连接运算)\n赋值运算符:=,+=,—=,*=,/=,%=\n比较运算符(关系):<,>,>=,<=,==,instanceof\n逻辑运算符:&,&&,|,||,^,!\n位运算符:<<,>>,>>>,&,|,^,~\n三目运算符:(条件判断)?表达式1:表达式2\n~~~\n##算数运算符\n~~~\n（前）++ 先运算后赋值\n (后) ++ 先赋值后运算\n (前)++ 或者(后)++运算不改变原来的数据类型。byte,char,short +1 会自动提升为int\n ~~~\n ~~~\n 典型例子\n int i=12;\n int j=i++;\n System.out.println(\"j=\"+j+\",i=\"+i);\n /*\n 结果:\n j=12,i=13\n */\n int i=12;\n int j=++i;\n System.out.println(\"j=\"+j+\",i=\"+i);\n /*\n 结果:\n j=13,i=13\n */\nbyte b=127;\nbyte b1=b++;\nSystem.out.println(\"b1=\"+b1+\",b=\"+b);\n/*\n结果:\nb1=127,b=-128\n*/\nbyte b=127;\nint i=b+1;//自动提升类型int\nSystem.out.println(\"b=\"+b+\",i=\"+i);\n/*\n结果\nb=127,i=128\n*/\n~~~\n~~~\n取模运算符的符号取决于被模数的符号\n~~~\n~~~\n经典例题\nint num1=19,num2=3;\nSystem.out.println(num1+\"%\"+num2+\"=\"+(num1%num2));\n/*\n结果 19%3=1\n*/\nint num1=-19,num2=3;\nSystem.out.println(num1+\"%\"+num2+\"=\"+(num1%num2));\n/*\n结果\n-19%3=-1\n*/\nint num1=19,num2=-3;\nSystem.out.println(num1+\"%\"+num2+\"=\"+(num1%num2));\n/*\n结果\n19%-3=1\n*/\nint num1=-19,num2=-3;\nSystem.out.println(num1+\"%\"+num2+\"=\"+(num1%num2));\n/*\n结果\n-19%-3=-1\n*/\n~~~\n~~~\n运算结果是浮点数若用整数类型存取直接取整。并不是遵循四舍五入原则\n~~~\n~~~\n典型例子\nint num1=28,num2=23;\nint result =num1/num2;\nSystem.out.println(result);\n/*\n结果:1\n*/\ndouble num=28.7;\nint result=(int)num;\nSystem.out.println(result);\n/*\n结果:28\n*/\n~~~\n##赋值运算符\n~~~\n赋值运算不改变原来的数据类型\n~~~\n~~~\n经典例子\nbyte i=10;\ni+=1;//相当于i=i+1但并不改变数据类型\nSystem.out.println(i);\n/*\n结果:11\n*/\n~~~\n##比较运算符\n~~~\n<,>,>=,<=相对于数值\ninstanceof相对于类   用于比较该实例是否是该类的继承和实现\n==相对于数值和String 用于比较内存地址是否一样\n~~~\n~~~\n经典例子\nString str=\"hello\";\nSystem.out.println(str instanceof String);\n/*\n结果:true\n原因任何一个字符串都是String的一个实例\n*/\nString s1=\"hello\",s2=\"hello\";\nSystem.out.println(s1==s2);\n/*\n结果:true\n原因:s1,s2字符串都分配在同一个栈内存中指向同一个地址\n*/\nString s1=new String(\"hello\");\nString s2=new String(\"hello\");\nSystem.out.println(s1==s2);\n/*\n结果:false\n原因：s1,s2字符串对象在堆内存分配的内存空间地址不一样\n*/\n~~~\n\n##逻辑运算符\n~~~\n条件与&,&&当两个变量的值是true时,结果才是true\n条件或|,||当两个变量其中的一个值是true,结果就是true\n条件异或^异或当两个变量结果一个是true，一个是false，结果才是true\n条件非！true变false,false变true\n~~~\n~~~\n&,&&之间的区别：&当第一个值为false时依旧会判断第二个值，&&当第一个值是false时不会判断第二个值，但他们运算的结果都是一样的\n同理:|,||的区别:|当第一个值为true时依旧会判断第二个值，||当第一个值是true时便不会判断第二个值，但他们运算结果都是一样的\n~~~\n~~~\n经典例题\nint num1=12,num2=18,temp=9;\nif(num1>num2&temp++>10){ //false,false\n}else{\nSystem.out.println(temp);\n}\n/*\n结果:10\n*/\nint num1=12,num2=18,temp=9;\nif(num1>num2&&temp++>10){ //false,false\n}else{\nSystem.out.println(temp);\n}\n/*\n结果:9\n*/\n~~~\n##位运算符\n~~~\n<< X\n相当于值的二进制向左移X位,后面位数用0补上，也是说*2^x\n>> x\n相当于值的二进制向右移X位，前面位数用符号位补上，也是说/2^x\n>>> x 无符号位右移\n相当于值的二进制向右移X位，前面都有0补上\n按位与& 当两个变量的二进制所在位数的值都为1时才为1\n按位或| 当两个变量的二进制所在位数的值其中一个为1就是1\n按位异或^ 当两个变量的二进制所在位数的值相反时才为1\n按位非~ 变量的二进制都取反\n~~~\n~~~\n经典例子\nSystem.out.println(9<<2);\n/*\n结果:9*2^2=36\n*/\nSystem.out.println(9>>2);\n/*\n结果:9/2^2=2\n*/\nSystem.out.println(-9>>2);\n/*\n结果:-9/2^2=-3（不知道什么原因需要进一步进行二进制分析）\n*/\n~~~\n~~~\n当两个变量进行两次二者之间异或位运算时，可以起到交换位置效果\n~~~\n~~~\nSystem.out.println(8^2^8);\n/*\n结果:2\n*/\nint i=8,j=2;\ni=i^j;\nj=i^j;\ni=i^j;\nSystem.out.println(\"i=\"+i+\",j=\"+j);\n/*\n结果:i=2,j=8\n*/\n~~~\n##交换两个变量的位置方法\n~~~\n直接进行交换法\n~~~\n~~~\n优点：不用分配一个临时变量的内存\n缺点：只使用于数值类型，且一定要在数据类型的取值范围内\nint i=8,j=2;\ni=i+j;\nj=i-j;\ni=i-j;\nSystem.out.println(\"i=\"+i+\",j=\"+j);\n~~~\n~~~\n异或位运算符法\n~~~\n~~~\n优点:不用分配一个临时变量的内存\n缺点:只使用于数值类型\nint i=8,j=2;\ni=i^j;\nj=i^j;\ni=i^j;\nSystem.out.println(\"i=\"+i+\",j=\"+j);\n~~~\n~~~\n增加另一个临时变量法\n~~~\n~~~\n(推荐)\n优点:可以使用任何类型\n缺点:需要分配一个临时变量的内存\nString s1=hello,s2=world;\nString temp=s1;\ns1=s2;\ns2=temp;\nSystem.out.println(\"s1=\"+s1+\",s2=\"+s2);\n~~~\n##三目运算符\n~~~\n三目运算符也称三元运算符通常需要三个变量。\n规定的格式(条件判断)?表达式1:表达式2\n可以嵌套\n三目运算符都需要一个返回值\n返回值需要和表达式1和表达式2进行类型统一\n~~~\n~~~\n经典例题\n两个数的比较\nint a=10,b=100;\nint max=(a>b)?a:b;//a,b与max要做到类型统一即max即可以保存a的值又可以保存b的值\nSystem.out.println(max);\n~~~\n~~~\n三个数的比较\n推荐\nint a=100,b=89,c=67;\nint max1=(a>b)?a:b;\nint max2=(max1>c)?max1:c;\nSystem.out.println(max2);\n或者(嵌套不推荐)\nint a=100,b=89,c=67;\nint max=((a>b)?a:b)>c?((a>b)?a:b):c;\nSystem.out.println(max);\n~~~\n##运算符的优先级(括号、单目、new 、算数、关系、与或、三目、赋值)\n~~~\n除了单目运算符、赋值运算符和条件运算符，其他的运算符都是从左到右结合的\n~~~\n~~~\n分割符\n.　　[]　　()　　,　　;\n单目运算符\n+　　-　　~　　!　　++　　--\n创建或类型转换\nnew　　(type)\n乘法/除法\n*　　/　　%\n加法/减法\n+　　-\n关系\n<　　<=　　>=　　>　　instanceof\n等价	\n==　　!=\n按位与\n&\n按位异或	\n^\n按位或	\n|\n条件与	\n&&\n条件或	\n||\n条件\n?　:\n赋值	\n=\n~~~\n\n', '2019-09-02', '算数运算符，赋值运算符，比较（关系）运算符，逻辑运算符，位运算符，三目运算符', '详解Java运算符', '0');
INSERT INTO `Blog` VALUES ('11', '##Java流程控制\n1.顺序结构\n2.分支结构\n3.顺序结构\n##顺序结构\n所有程序都是依照顺序结构执行\n##分支结构\n###1.\nif(boolen值表达式){\n    语句1..n;\n}\nelse{\n    语句1..n;\n}\n###2.\nif(boolen值表达式){\n    语句1...n;\n}\nelse if(boolen值表达式){\n 	语句1...n;\n} \nelse{\n   语句1...n;\n}\n##if..else if ...else...经典例子\n~~~\n        int source = 76;\n        if (source>80)\n        {\n            System.out.println(\"成绩大于80\");\n        }\n        else if (source>70)\n        {\n            System.out.println(\"成绩大于70\");\n        }\n        else if (source>60)\n        {\n            System.out.println(\"成绩大于60\");\n        }\n        else {\n            System.out.println(\"成绩不合格\");\n        }\n		/*\n		结果:成绩大于70\n		*/\n~~~\n~~~\n        int source = 76;\n        if (source>80)\n        {\n            System.out.println(\"成绩大于80\");\n        }\n        else if (source>60)\n        {\n            System.out.println(\"成绩大于60\");\n        }\n        else if (source>70)\n        {\n            System.out.println(\"成绩大于70\");\n        }\n        else {\n            System.out.println(\"成绩不合格\");\n        }\n		/*\n		结果:成绩大于60\n		*/\n~~~\n##结论\n1.if..else if...else...当符合其中一个条件时，即使后面还有判断语句也不会执行\n2.当我们有范围小的和范围大的判断条件时，我们要采取将范围小的判断条件放在范围大的判断条件前面，否则范围小的将永远不会执行\n###3.\nswitch(表达式)\n{\ncase 常量:语句1...n;braek;\ncase 常量:语句1...n;break;\ndefault:语句1...n;break;\n}\n##分支语句注意点\n1.switch()表达式中只能使用 byte,char,short,int,enum(jdk1.5),String(jdk1.7)，且常量值要和表达式的值匹配\n2.若case之后没有break关键字则会继续执行下面的判读\n##使用了break关键字的switch和不使用break时的区别\n~~~\n    int source = 76;\n    switch(source/60)\n    {\n        case 1:\n            System.out.println(\"成绩合格\");break;\n        default:\n            System.out.println(\"成绩不合格\");break;\n\n    }\n	/*\n	结果:成绩合格\n	*/\n	\n~~~\n~~~\n    int source = 76;\n    switch(source/60)\n    {\n        case 1:\n            System.out.println(\"成绩合格\");\n        default:\n            System.out.println(\"成绩不合格\");\n\n    }\n	/*\n	结果：\n	成绩合格\n	成绩不合格\n	*/\n~~~\n##结论\n1.当switch分支结构使用break时当匹配到了条件时就会跳出判断，若后面有语句将不会再执行。\n2.当switch分支结构不使用break关键字时当匹配到了条件时并不会跳出判断继续执行后面的判断语句\n##循环结构\n###1.\nfor(①;②;④)\n{\n   ③；\n}\n###2.\n①\nwhile(②)\n{\n  ③;\n  ④;\n}\n###3.\n①;\ndo{\n③;\n④;\n}while(②);\n##循环结构注意\n1.①是初始化条件；②是判断条件boolen类型；③是循环体；④是迭代条件\n2.无限循环结构for(;;) while(true)\n##do{}while()和while的区别\n~~~\n        int i = 10;\n        while (i > 5) {\n            i--;\n        }\n        System.out.println(i);\n        int j = 10;\n        do {\n            j--;\n        } while (j > 5);\n        System.out.println(j);\n		/*\n		结果：\n		i=5,j=5\n		*/\n~~~\n~~~\n        int i = 10;\n        while (i < 5) {\n            i--;\n        }\n        System.out.println(i);\n        int j = 10;\n        do {\n            j--;\n        } while (j < 5);\n        System.out.println(j);\n		/*\n		结果:\n		i=10,j=9\n		*/\n~~~\n##结论:\n1.当循环可以进入时，do{}while();和while（）{}结果没区别\n2.当循环不可以进入时,do{}while();都需要执行一次循环体;while(){}无法执行循环体\n##结束循环结构的方法\n1.定义标识 boolen isFlag=true;\n2.break关键字\n3.continue关键字\n##break,continue,return关键字区别和相同点\n1.break,continue用于循环结构中，结束循环，不能用于顺序结构和分支结构（switch例外）\n2.return用于方法中\n3.break用于结束当前循环，后面不能写执行语句\n4.continue用于结束当次循环,后面不能写执行语句\n5.return用于结束当前方法，后面不能执行语句\n##break,continue区别例子\n~~~\n        for(int i=1;i<=10;i++)\n        {\n            if (i%2==0)\n            {\n                break;\n            }\n            System.out.println(i+\"\\t\");\n        }\n		/*\n		结果:1\n		*/\n~~~\n~~~\n        for(int i=1;i<=10;i++)\n        {\n            if (i%2==0)\n            {\n                continue;\n            }\n            System.out.println(i+\"\\t\");\n        }\n		/*\n		结果:1,3,5,7,9\n		*/\n~~~\n##结论\n1.当执行到break关键字时整个循环退出\n2.当执行到continue关键字时当次循环退出，进行下一次循环\n\n', '2019-09-12', '详解流程控制结构，顺序结构；分支结构；循环结构；break,continue，return关键字', 'Java流程控制', '0');
INSERT INTO `Blog` VALUES ('12', '~~~\n/*\n从键盘输入一个年份判断其年份是闰年还是平年\n思路\n闰年的判断方法 闰年二月份29天，平年二月份28天\n能被4整除但不能被100整除或者能被400整除的数\n*/\nimport java.util.Scanner;\npublic class Demo\n{\n public static void main(String[] args)\n {\n     //从键盘输入一个年份\n	 System.out.print(\"请从键盘输入一个年份:\");\n	 Scanner scanner = new Scanner (System.in);\n	 int year=scanner.nextInt();\n	 //对月份进行判断分支结构\n	 //能被4整除但不能被100整除或者能被400整除\n	 if((year%4==0&&year%100!=0)&&(year%400==0))\n	 {\n	     System.out.println(year+\"年是闰年\");\n	 }\n	 else{\n	      System.out.println(year+\"年是平年\");\n	 }\n }\n}\n  /*\n   结果\n   请从键盘输入一个年份:2019\n   2019年是平年\n  */ \n~~~', '2019-09-12', '从键盘输入一个年份判断其年份是闰年还是平年(能被4整除但不能被100整除或者能被400整除的数)', '闰年和平年算法', '3');
INSERT INTO `Blog` VALUES ('13', '~~~\nimport java.util.Scanner;\n/*\n写一个方法:从键盘分别输入年月日这三个参数判断该日是这一年的多少天\n */\npublic class Demo {\n    public static void main(String[] args) {\n        //定义年份，月份，日期，天数的变量\n        int year = 0, month = 0, day = 0, sum = 0;\n        Scanner scanner = new Scanner(System.in);\n        //定义是否退出循环的标识\n        boolean isFlag = true;\n        //如果输入年份有误则重新输入年份\n        while (isFlag) {\n            System.out.println(\"请从键盘输入一个年份:\");\n            year = scanner.nextInt();\n            if (year < 0) {\n                System.out.println(\"年份输入有误，请重新输入\");\n            } else {\n                //退出循环\n                isFlag = false;\n            }\n        }\n        //重新初始化标识\n        isFlag = true;\n        //如果输入月份有误重新输入月份\n        while (isFlag) {\n            System.out.println(\"请从键盘输入一个月份:\");\n            month = scanner.nextInt();\n            if (month < 0 || month > 12) {\n                System.out.println(\"月份输入有误，请重新输入\");\n            } else {\n                //退出循环\n                isFlag = false;\n            }\n        }\n        //重新初始化标识符\n        isFlag = true;\n        //如果输入日期有误重新输入日期\n        while (isFlag) {\n            System.out.println(\"请从键盘输入一个日期:\");\n            day = scanner.nextInt();\n            switch (month) {\n                case 1:\n                case 3:\n                case 5:\n                case 7:\n                case 8:\n                case 10:\n                case 12:\n                    if (day > 0 && day < 31) {\n                        isFlag = false;\n                    } else {\n                        System.out.println(\"日期输入有误，请重新输入\");\n                    }\n                    break;\n                case 2:\n                    if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                        if (day > 0 && day < 29) {\n                            //当输入符合条件时退出循环\n                            isFlag = false;\n                        } else {\n                            System.out.println(\"日期输入有误，请重新输入\");\n                        }\n                    } else {\n                        if (day > 0 && day < 28) {\n                            isFlag = false;\n                        } else {\n                            System.out.println(\"日期输入有误，请重新输入\");\n                        }\n                    }\n                    break;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    if (day > 0 && day < 30) {\n                        isFlag = false;\n                    } else {\n                        System.out.println(\"日期输入有误，请重新输入\");\n                    }\n                    break;\n            }\n        }\n        //计算天数的算法 不使用break,从12月份开始匹配若匹配到则从该月份向下开始加\n        switch (month) {\n            case 12:\n                sum += 30;\n                //11月30天\n            case 11:\n                sum += 31;\n                //10月31天\n            case 10:\n                sum += 30;\n                //九月30天\n            case 9:\n                sum += 31;\n                //八月31天\n            case 8:\n                sum += 31;\n                //七月31天\n            case 7:\n                sum += 30;\n                //6月30天\n            case 6:\n                sum += 31;\n                //5月31天\n            case 5:\n                sum += 30;\n                //40月30天\n            case 4:\n                sum += 31;\n                //三月31天\n            case 3:\n                //判断闰年还是平年\n                if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                    sum += 29;\n                } else {\n                    sum += 28;\n                }\n            case 2:\n                sum += 31;\n                //一月31天\n            case 1:\n                sum += day;\n        }\n        //输出天数\n        System.out.println(year + \"年\" + month + \"月\" + day + \"日是这一年的\" + sum + \"天\");\n    }\n}\n~~~', '2019-09-12', '写一个方法:从键盘分别输入年月日这三个参数判断该日是这一年的多少天', '判断该日是这一年的多少天的算法', '3');
INSERT INTO `Blog` VALUES ('14', '~~~\npublic class Algorithm {\n	/*\n	 * 求两个数之间的最大公约数\n	 */\n	public int GCD(int num_1, int num_2) {\n		// 求两数之间最小值\n		int min = (num_1 <= num_2) ? num_1 : num_2;\n		int result = min;\n		// 从最小值开始遍历到1判断两个数是否都被result除尽\n		for (; result >= 1; result--) {\n			if (num_1 % result == 0 && num_2 % result == 0) {\n				// 当找到最大公约数时退出循环\n				break;\n			}\n		}\n		// 返回最大公约数\n		return result;\n	}\n\n	/*\n	 * 求两个数之间的最小公倍数\n	 */\n	public int LCM(int num_1, int num_2) {\n		// 求两数之间最大值\n		int max = (num_1 >= num_2) ? num_1 : num_2;\n		int result = max;\n		// 从两个数最大值开始遍历到两个数之积判断result是否都被两个数除尽\n		for (; result < num_1 * num_2; result++) {\n			if (result % num_1 == 0 && result % num_2 == 0) {\n				// 找到最小公倍数时退出循环\n				break;\n			}\n		}\n		// 返回最小公倍数\n		return result;\n	}\n}\n~~~', '2019-09-25', '求两个数之间的最大公约数,最小公倍数。如:12,20最大公约数4;12,20最小公倍数60', '求两个数之间的最大公约数，最小公倍数算法', '3');

-- ----------------------------
-- Table structure for Category
-- ----------------------------
DROP TABLE IF EXISTS `Category`;
CREATE TABLE `Category` (
  `id` int(11) NOT NULL,
  `category_name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of Category
-- ----------------------------
INSERT INTO `Category` VALUES ('0', 'Base');
INSERT INTO `Category` VALUES ('1', 'Bug');
INSERT INTO `Category` VALUES ('2', 'Environment');
INSERT INTO `Category` VALUES ('3', 'Demo');
INSERT INTO `Category` VALUES ('4', 'Document');

-- ----------------------------
-- Table structure for User
-- ----------------------------
DROP TABLE IF EXISTS `User`;
CREATE TABLE `User` (
  `id` int(11) NOT NULL,
  `nick_name` varchar(255) DEFAULT NULL,
  `sign` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of User
-- ----------------------------
INSERT INTO `User` VALUES ('1', '君莫笑', '醉卧沙场君莫笑');
